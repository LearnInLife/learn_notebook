# 面向对象

[TOC]



面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 

面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。



## 类和对象

类是一种抽象的概念，是具有相同属性和行为事物的统称。

对象就是一个具体存在的事物，是根据类这个抽象的模板创建出来的一个实例

面向对象的设计思想就是抽象出类（Class），根据类（Class）创建实例（Instance ）



## 类

类(Class) 由3个部分构成

- 类的名称:类名
- 类的属性:一组数据
- 类的方法:允许对进行操作的方法 (行为)



### 类的定义

定义一个类，格式如下 ：

```python
class 类名(object):
    <语句--1>
    .
    .
    <语句--n>
```

* 定义类使用class关键字
* 类名开通通常大写,采用驼峰的方式命名
* (object)表示该类从哪个类继承下来。所有类最终都会继承object类。
* 类中包含了属性和方法



### 类的使用

创建对象的格式为: 

```
对象名 = 类名()
```

类使用例子：

```python
class MyClass(object):
    #定义方法
    def fuc(self):
        print('hello')
        
        
#类的使用，创建对象实例
my_class = MyClass()
#调用对象的方法
my_class.fuc()
#给对象添加属性
my_class.name='bbb'
print(my_class.name)

#结果
'hello'
'bbb'
```



### 类的构造函数`__init__`

```python
def 类名:
    #初始化函数，用来完成一些默认的设定
    def __init__(self):
        pass
```

如果我们在创建对象的时候，需要绑定一些默认的属性，则可以在可以通过`__init__`方法，进行设置。

```python
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
```

`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。 

当`__init__`有其他参数时，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去： 

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.name
'Bart Simpson'
>>> bart.score
59
```

总结：

* 即使没有显示定义`__init__()`方法，在实例化是系统会调用默认的构造方法

* `__init__()`方法，在创建一个对象时默认被调用，不需要手动调用
* `__init__(self)`中，默认第一个参数永远是`self`，如果`__init__(self)`中除了self外还有其他参数，则在创建对象实例的时候，就需要传入相应的参数，`self`除外
* `__init__(self)`中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去
* 一个类中可以定义多个`__init__()`方法，但最后的方法会覆盖前面的方法，所以必须要以最后一个`__init__()`的形式进行实例化



### 访问限制

在类内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。 

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.score
59
>>> bart.score = 99
>>> bart.score
99
```

但是，通过上面可以看出，外部代码还是可以自由地修改一个实例的`name`、`score`属性。

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 。如下：

```python
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
```

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
```

通过添加了`__`，外部便不能通过`实例变量.__name`和`实例变量.__score` 访问对象属性了，这样就通过访问限制的保护 ，确保了外部代码不能熟悉修改对象内部的属性，使代码更加健壮。



虽然不能通过对象名.属性名 进行直接访问了，但是可以通过给类添加方法，来访问相应的属性。

```python
class Student(object):
    ...
    
    #设置__score的值
    def set_score(self, score):
        self.__score = score
        
    #获取__score的值
    def get_score(self):
        return self.__score
        
    #获取__name的值
    def get_name(self):
        return self.__name
   
```

通过方法来访问设置相应的属性的好处在于，可以在方法中对传入参数进行检查，避免无效的参数



需要注意的是，在Python中，变量名类似`__xxx__`的，以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用`__name__`、`__score__`这样的变量名。

以一个下划线开头的实例变量名，比如`_name`，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

其实，私有属性并非不能直接访问，只是Python解释器将私有属性修改了而已。比如：`__name`变量改成了`_Student__name` ，所以仍然可以通过`_Student__name`来访问`__name`变量 。**但强烈建议不要这么做**

```python
>>> bart._Student__name
'Bart Simpson'
```



最后注意下面的这种**错误写法**： 

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.get_name()
'Bart Simpson'
>>> bart.__name = 'New Name' # 设置__name变量！
>>> bart.__name
'New Name'
```

表面上看，外部代码“成功”地设置了`__name`变量，但实际上这个`__name`变量和class内部的`__name`变量**不是**一个变量！内部的`__name`变量已经被Python解释器自动改成了`_Student__name`，而外部代码给`bart`新增了一个`__name`变量。

```python
>>> bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
```



总结：

- Python中没有像C++中public和private这些关键字来区别公有属性和私有属性
- 它是以属性命名方式来区分，如果在属性名前面加了2个下划线'__'，则表明该属性是私有属性，否则为公有属性
- 方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，外部无法直接访问。



### 继承

在OOP程序设计中，当定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。 

```python
# 定义一个父类，如下:
class Cat(object):

    def __init__(self, name):
        self.name = name

    def run(self):
        print("%s--在跑"%self.name)


# 定义一个子类，继承Cat类如下:
class Bosi(Cat):

    def __init__(self,name,color='白色'):
        #调用父类的构函数
        super(Bosi,self).__init__(name)
        self.color = color
    
    def setNewName(self, newName):
        self.name = newName

    def eat(self):
        print("%s--在吃"%self.name)
        
        
bs = Bosi("印度猫")
print('bs的名字为:%s'%bs.name)
print('bs的颜色为:%s'%bs.color)
bs.eat()
bs.setNewName('波斯')
bs.run()

#运行结果
bs的名字为:印度猫
bs的颜色为:白色
印度猫--在吃
波斯--在跑
```

* 如果子类没有定义`__init__`方法，就会继承父类的`__init__`的方法，在创建子类实例的时候，会默认执行那个继承过来的`__init__`方法 
* 如果子类定义了`__init__`方法，就需要在子类的构造方法中直接调用父类的构造函数
* 继承最大的好处是子类继承了父类全部非私有的功能



**注意：**

```python
class Animal(object):

    def __init__(self, name='动物', color='白色'):
        self.__name = name
        self.color = color

    def __test(self):
        print(self.__name)
        print(self.color)

    def test(self):
        print(self.__name)
        print(self.color)



class Dog(Animal):
    def dogTest1(self):
        #print(self.__name) #不能访问到父类的私有属性
        print(self.color)


    def dogTest2(self):
        #self.__test() #不能访问父类中的私有方法
        self.test()


A = Animal()
#print(A.__name) #程序出现异常，不能访问私有属性
print(A.color)
#A.__test() #程序出现异常，不能访问私有方法
A.test()

print("------分割线-----")

D = Dog(name = "小花狗", color = "黄色")
D.dogTest1()
D.dogTest2()
```

- 私有的属性，不能通过对象直接访问，但是可以通过方法访问
- 私有的方法，不能通过对象直接访问
- 私有的属性、方法，不会被子类继承，也不能被访问
- 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用



继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。

```
                ┌───────────────┐
                │    object     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Animal    │           │    Plant    │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
```



### 多态









